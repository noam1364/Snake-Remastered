.486
.model flat, stdcall
option casemap:none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
include \masm32\include\user32.inc
include \masm32\include\msvcrt.inc
includelib msvcrt.lib
include drd.inc
includelib drd.lib
;sound
includelib \masm32\lib\winmm.lib 
include \masm32\include\winmm.inc

.data

	time SYSTEMTIME {}

    w_width dword 700
    w_height dword 700

    background_off byte "background.bmp",0
    background_obj Img <0,0,0,0>

	 platform_off byte "platform.bmp",0
     platform_obj Img <0,0,0,0>


	 char_off byte "char.bmp",0
     char_obj Img <0,0,0,0>

	x_pos dword 200 ;can be changed acording to the picture
	y_pos dword 480	;can be changed acording to the picture
	vy dword 1 ; will be changed
	g dword 1

	x_platform dword 3 dup (?)    ;the first plate x and y 
	y_platform dword 3 dup (?)

	random_x dword ?
	speed byte 40


.code

X macro args:VARARG
    asm_txt TEXTEQU <>
    FORC char,<&args>
        IFDIF <&char>,<!\>
            asm_txt CATSTR asm_txt,<&char>
        ELSE
            asm_txt
            asm_txt TEXTEQU <>
        ENDIF
    ENDM
    asm_txt
endm


	initiate PROC

    pusha
        invoke drd_init ,w_width,w_height,INIT_WINDOW
        invoke drd_imageLoadFile ,offset background_off,offset background_obj
		invoke drd_imageLoadFile ,offset platform_off,offset platform_obj
		invoke drd_imageLoadFile ,offset char_off,offset char_obj

		X mov x_platform[0],150 \  mov y_platform[0],550
		X mov x_platform[4],300 \  mov y_platform[4],400
		X mov x_platform[8],450 \  mov y_platform[8],200

    popa
    ret
    initiate endp


	random PROC
	pusha
		invoke GetSystemTime,addr time
			xor eax,eax
			X	mov ax,time.wMilliseconds \ add ax,1 \ mov bx,2 \ div bx
			mov random_x,eax
				
	popa
	ret
	random endp


    draw_pictures PROC

    pusha
        invoke drd_imageDraw,offset background_obj,0,0
		invoke drd_imageDraw,offset platform_obj,x_platform[0],y_platform[0]
		invoke drd_imageDraw,offset platform_obj,x_platform[4],y_platform[4]
		invoke drd_imageDraw,offset platform_obj,x_platform[8],y_platform[8]
		invoke drd_imageDraw,offset char_obj,x_pos,y_pos

    popa
    ret
    draw_pictures endp


	user_input PROC
	pusha

		X invoke	GetAsyncKeyState,VK_UP \ cmp eax,0 \ jne up
		X invoke	GetAsyncKeyState,VK_RIGHT \ cmp eax,0 \ jne right
		X invoke	GetAsyncKeyState,VK_LEFT \ cmp eax,0 \ jne left
		jmp exit

		right:
		X mov eax,x_pos \ add eax,20 \ cmp eax,700 \ je exit
		X	add x_pos,20 \ jmp exit

		left:
		X mov eax,x_pos  \ cmp eax,0 \ je exit
		X	sub x_pos,20 \ jmp exit

		up:
		X cmp vy,1 \ jne exit
		X mov y_pos,0 \ je exit
	    mov vy,20 

	exit:
	popa
	ret 
	user_input endp


	movment_manager PROC

	pusha

		;air_movment:
		X cmp y_pos,0 \ jne continue2
		mov vy,1

		continue2:
		X mov eax,vy \ add y_pos,eax
		X dec vy



		continue:
		xor esi,esi
		loop1:
		X	cmp esi,3 \ je exit
		add y_platform[esi*4],1
		X	inc esi \ jmp loop1

	exit:
	popa
	ret
	movment_manager	endp


	collitions PROC

	pusha
		xor esi,esi
		loop2:
		X	cmp esi,3 \ je continue
		X cmp y_platform[esi*4],700 \ je new_platform
		X	inc esi \ jmp loop2

		new_platform:   ; esi reamins the same
		invoke random
		X mov eax,random_x \ mov x_platform[esi*4],eax
		mov y_platform[esi*4],0

		continue:
		xor esi,esi
		loop1:
		X mov eax,x_platform[esi*4] \ cmp eax,x_pos \ jl exit
		X mov eax,x_platform[esi*4] \ add eax,200 \ cmp eax,x_pos \ jg exit
		X mov eax,y_platform[esi*4] \ cmp eax,y_pos \ jne exit
		X mov vy,1 \ inc esi
		jmp loop1

	exit:
	popa
	ret
	collitions endp



    main PROC
    
    invoke initiate
    again:
    invoke drd_processMessages
    invoke drd_flip
    invoke draw_pictures
	invoke user_input
	invoke movment_manager
	invoke Sleep,speed
    jmp again
    main endp

    end main
